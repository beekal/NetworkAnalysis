---
title: "Terrorising the Terrorists"
output: html_document
---

Read the CSV file first
------------------------------


```{r}
# install.packages('network')
# install.packages('intergraph')
# install.packages('ggplot2')
# install.packages('statnet')
# install.packages('numDeriv')
# install.packages('yacca')
# install.packages('rgl')
# install.packages('coda')
# install.packages('rgl')
# install.packages('tnet')
# install.packages('RSiena')
# install.packages('rgl')
# install.packages('rgl')
# install.packages('rgl')
library('MASS')

library('statnet')
library('intergraph')
setwd("C:\\Users\\Lenovo B4400\\Google Drive\\0 Projects\\Terrorising the Terrorists\\Data\\")
getwd()
data <- read.csv("911 dataset As CSV-edit.csv",head=FALSE, sep = ",")
data
dim(data)
data[1,1]
data[,1]

EV <- eigen(data)
EV
EV$values[1:5]
```

KEY Actor Analysis
-----------------------------------
**Critical Gatekeeper** (Conway, 2009). An individual that is central to the functioning of the network. If we assume a linear relationship between eigenvector centrality and betweeness and regress betweeness on eigenvector centrality, the residuals can be used to identify key players (Conway, 2009). A vertex or individual with higher levels of betweenness and lower EV centrality may be a 'critical gatekeeper or an individual that is central to the functioning of the network.

These people connect people to a network that otherwise would be isolated from the core.

**Individuals with Unique acess to the critical gatekeepers of the network** lower levels of betweeness and higher EV centrality These people are highly likely at the core of a network and are well connected.


```{r}
library(igraph)
dim(data)
data
#G<- graph.adjacency(data, mode = c("directed"))
data[1:2,1:2]
#D22 means data two by two only extracted from whole dataset
D22 <- data[1:2,1:2]
D22
#G<- graph.adjacency(D22, mode = c("undirected"))

library(igraph)
A <- matrix(c(0,1,1,0),2,2, byrow= TRUE)
A
D22

colnames(D22) = c("C","D")
D22

B <- as.matrix(D22,2,2,byrow = TRUE)
B

G<-graph.adjacency(B, mode=c("undirected")) 
G<-graph.adjacency(A, mode=c("undirected")) 

# now implementing for all data
DAll <- as.matrix(data,43,43,byrow=TRUE)
DAll
G<-graph.adjacency(DAll, mode=c("undirected")) 

DtWithName <- DAll
DtWithName
colnames(DtWithName) = c("Nawaf Alhazmi","Ahmed Alnami","Saeed Alghamdi","Ahmed Alghamdi","Hamza Alghamdi","Abdul Aziz Alomari","Mohamed Atta","Ramzi Bin al-Shibh","Salem Alhazmi","Hani Hanjour","Yazid Sufaat","Walid Ba Attas","Khalid Almihdar","Majed Moqed","Nabil al - Marabh","Ahmed Al Haznaw","Raed Hijazi","Mohand Alsheri","Ziad Jarrah","Waleed Alshehri","Marwan Al-shehhi","Wail Alshehri","Satam Suqami","Fayez Ahmed","Said Bahaji","Zakariya Essabar","Mounir El Motassadeq","Mohamed Haydar Zammar","Mahmoun Darkazanli","Essid Sami","Abdelghani Mzoudi","Ahmed Khalil","Imad Eddin","Agus Budi man","Mustafa Ahmed al-Hisawi","Khalid Shaikh Mohammed","Zacarias Moussaoui","Faisal Al Salmi","Rayed Mohammed Abdullah","Fahad al Quso","Ahmed Al-Haha","Bandar Alhazmi","Mohamed Abdi")
DtWithName
G1<-graph.adjacency(DtWithName, mode=c("undirected")) 
plot(G1)

cent1<-data.frame(bet1=betweenness(G1),eig1=evcent(G1)$vector) 
cent1
bet=as.vector(betweenness(G1))
normbet = (bet - mean(bet))/sd(bet)
hist(normbet)
eig=as.vector(evcent(G1)$vector)
normeig = (eig - mean(eig))/sd(eig)
hist(normeig)
cent2<-data.frame(normbet,normeig) 
cent2
lm(normeig~normbet,data=cent2)
cor(normeig,normbet)
cor(normbet,normeig)



# V1 0.591 = 191.59*betcoef +intercept
# 0.591 = 191.59 * 0.00263 + 0.23 = (0.733) residual then is  -0.14
summary(as.vector(evcent(G1)$vector))
sd(as.vector(evcent(G1)$vector))
hist(as.vector(evcent(G1)$vector))
hist(as.vector(betweenness(G1)), bins =20)
plot(as.vector(evcent(G1)$vector))
plot(as.vector(betweenness(G1)), bins =20)

summary(as.vector(betweenness(G1)))
sd(as.vector(betweenness(G1)))
# library('Mass')
# install.packages('Mass')
bet1 = as.vector(betweenness(G1))
deg1 = as.vector(degree(G1))
normdeg = (deg1 - mean(deg1))/sd(deg1)

plot(normbet,normdeg)

betweenness(G1)
degree(G1)

summary(eig1)

lm(eig1~bet1,data=cent1)
 # eig = 0.00263 * bet + 0.23 implies that there is very low relationship between the  betweenness and the eigen vector when it comes to terrorist network relation. this means that the more connected a terrorist is does not mean he is  connected to other critical nodes. He might in fact be just a gatekeeper i.e he sanitise the core of the network from the operational activities so that if a operational actor is compromised then it does not lead to compromise of the core networks. this increases the resilience of the terrorist networks i.e cell operations prevent one cells compromise from propagating to the whole network compromise. This means whatever comprimise happens at the operational level, the core is never compromised. Gatekeepers are important to break the operational strength of the network, while they do not compromise the true strategic strenght of the network.
#  A strategy must be devised keeping in mind the structure of the network. Identyfing  is not the  key, its a important event  but not the key. The key is maximising the knowledge to the fullest without letting the enemy know that their network has been compromised.Just as breaking the enigma was not the key. The key is then to using the information gained to the maximum full potential, without letting the enemy know that the  network has been compromised. You must be ready to   operational level, the terror network will be able to outlast. 

# Correlating with the maoist network.

lm(eig1~bet1,data=cent1)$residuals
# Extremely large value of residuals indicate that the general assumption do not hold true for that particular instance and we can then look at why is the general assumption not holding true for that and wht is the factor that affects so. This might lead to comple new finding s as to in what case can we expect different result.

res1<-as.vector(lm(eig1~bet1,data=cent1)$residuals)   
cent1<-transform(cent1,res=res1)
cent1

plot(G1, layout = layout.fruchterman.reingold)   

plot(G1, layout = layout.fruchterman.reingold, vertex.size = 20*evcent(G1)$vector, vertex.label = as.vector(rownames(cent1)), main = 'Network Visualization in R')

```
Explore Graph using Sna
```{r}
library("sna")
DtWithName
stress = stresscent(DtWithName)
DtWithName[1,7]
DtWithName[1,1]

G1<-graph.adjacency(DtWithName, mode=c("undirected")) 
tkplot(G1, layout=layout.kamada.kawai, vertex.size = stress / 70)
wc <- walktrap.community(G1)
# Conceptually, high-stress vertices lie on  a large number of shortest paths between other vertices; they can thus be thought of as "bridges" or "boundary spanners."
plot( wc, G1, layout = layout.fruchterman.reingold, vertex.size = stress / 70 )
cor(bet,stress)
gcent = graphcent(DtWithName)
plot( wc, G1, layout = layout.fruchterman.reingold, vertex.size = gcent * 10 )

RGU
G4<-graph.adjacency(RGU, mode=c("undirected")) 
tkplot(G4)

DtWithName
triad.classify(DtWithName,tri=c(1,2,4), mode = "graph")
triad.classify(DtWithName,tri=c('Nawaf Alhazmi',3,4), mode = "graph")
which( DtWithName == 'Mohamed Abdi' )

which(colnames(DtWithName) == 'Mohamed Abdi')

# In general, actors with higher information centrality are predicted to have greater control over the
# flow of information within a network; highly information-central individuals tend to have a large
# number of short paths to many others within the social structure.

info = infocent(DtWithName)
info
cor(info,bet)
plot( wc, G1, layout = layout.fruchterman.reingold, vertex.size = info*5 )
bon = bonpow(G1, exponent = 0)
cor(bon, bet)
plot( wc, G1, layout = layout.fruchterman.reingold, vertex.size = degree(G1) )

memb <- sample(1:3, 10, replace = TRUE)
modularity(wc)
membership(wc)
as.list(wc)
membwc = as.vector(wc[3]$membership)
membwc
DtWithName
summary(brokerage(DtWithName, membwc))
brokerage <-brokerage(DtWithName, as.vector(membership(wc)))
brokerage
# coordinator  the broker mediates contact between two individuals from his or her own group. Two-path structure: A ! A ! A
coord = brokerage$raw.nli[,1]
plot( wc, G1, layout = layout.fruchterman.reingold, vertex.size = brokerage$raw.nli[,1]/5 )
# wO: Itinerant broker role; the broker mediates contact between two individuals from a single
# group to which he or she does not belong. Two-path structure: A ! B ! A. 
plot( wc, G1, layout = layout.fruchterman.reingold, vertex.size = brokerage$raw.nli[,2] * 2 )

# . bIO: Representative role; the broker mediates an incoming contact from an out-group member
# to an in-group member. Two-path structure: A ! B ! B
plot( wc, G1, layout = layout.fruchterman.reingold, vertex.size = brokerage$raw.nli[,3] /5 )


# . bOI : Gatekeeper role; the broker mediates an outgoing contact from an in-group member to
# an out-group member. Two-path structure: A ! A ! B
plot( wc, G1, layout = layout.fruchterman.reingold, vertex.size = brokerage$raw.nli[,4] /5 )


# . bO: Liaison role; the broker mediates contact between two individuals from different groups,
# neither of which is the group to which he or she belongs. Two-path structure: A ! B ! C
plot( wc, G1, layout = layout.fruchterman.reingold, vertex.size = brokerage$raw.nli[,5]/4  )


hierarchy(G1)
eq <- equiv.clust(DtWithName)
plot(eq,  G1 )
b <- blockmodel(DtWithName, eq, h = 15)
brokerage
g.e <- blockmodel.expand(b, rep(2, length(b$rlabels)))
# to explore further blockmodel
#Generate a random graph

RG<-rgraph(10)
G3<-graph.adjacency(RG, mode=c("directed")) 
tkplot(G3)
#Classify the triads (1,2,3) and (2,3,4)
triad.classify(RG,tri=c(1,2,3))
triad.classify(RG,tri=c(2,3,4))

set.seed(1234)
RGU<-rgraph(10, mode = "graph")
G4<-graph.adjacency(RGU, mode=c("undirected")) 
tkplot(G4)
#Classify the triads (1,2,3) and (2,3,4)
# with the return value being the number of edges.
# Result : 0 neither vetex are connected
triad.classify(RGU,tri=c(1,2,4), mode = "graph")
# Result : 1  One vetex is connected i.e 2  and 3
triad.classify(RGU,tri=c(1,2,3), mode = "graph")
# Result : 2  two vetex is connected i.e 1 and 8 and 1 and 7
triad.classify(RGU,tri=c(1,8,7), mode = "graph")
# Result : 3  all vetex are connected i.e 1 and 8 and 5
triad.classify(RGU,tri=c(1,8,5), mode = "graph")


triad.classify(RGU,tri=c(1,2,4), mode = "graph")

gplot3d(DtWithName,rgws(1,5,3,1,0))

# gplot3d.layout.adj(DtWithName, layout.par = rgws(1,5,3,1,0))
# gplot3d.layout.eigen(DtWithName, layout.par)
# gplot3d.layout.fruchtermanreingold(DtWithName, layout.par)
# gplot3d.layout.geodist(DtWithName, layout.par)
# gplot3d.layout.hall(DtWithName, layout.par)
# gplot3d.layout.kamadakawai(DtWithName, layout.par)
# gplot3d.layout.mds(DtWithName, layout.par)
# gplot3d.layout.princoord(DtWithName, layout.par)
# gplot3d.layout.random(DtWithName, layout.par)
# gplot3d.layout.rmds(DtWithName, layout.par)
# gplot3d.layout.segeo(DtWithName, layout.par)
# gplot3d.layout.seham(DtWithName, layout.par)

#Plot the triads in question
gplot(g[1:3,1:3])
gplot(g[2:4,2:4])

wc
b$raw.nli[,1]

G2<-graph.adjacency(g.e, mode=c("undirected")) 
plot(G2)

g <- rgraph(10, 3, tprob=c(0.1, 0.9, 0.5))
g.p <- sapply((1:10) / 10, rep, 10)
g <- rgraph(10, tprob = g.p)
apply(g, 2, mean)
g <- rgnm(5, 10, 12)
apply(g, 1, sum)


```


**Generate an Interactive plot :**
```{r}
tkplot(G1, layout=layout.kamada.kawai)

# V(G1)
# degree(G1)
vdg <- as.vector(degree(G1))
vdg/max(vdg)

weight(G1)

V(G1)$label.cex <- 2.2 * vdg / max(vdg)+ .2
V(G1)$label.color <- rgb(0, 0, .2, .8)
V(G1)$frame.color <- NA
#egam <- (log(E(G1)$weight)+.4) / max(log(E(G1)$weight)+.4)
#E(G1)$color <- rgb(.5, .5, 0, egam)
#E(G1)$width <- egam
# plot the graph in layout1
plot(G1, layout=layout.kamada.kawai)
simplify(G1)
tkplot(G1, layout=layout.kamada.kawai,  vertex.size = 20*evcent(G1)$vector)
V(G1)$name

```

Key Actor Analysis
---------------------------

```{r}
library(ggplot2)
p<-ggplot(cent1,aes(x=bet1,y=eig1,label=rownames(cent1),colour=res1,              size=abs(res1)))+xlab("Betweenness Centrality")+ylab("Eigenvector Centrality")
pdf('key_actor_analysis_terror.pdf')
p+geom_text()
dev.off()

```

**Degree Centrality ** : *How well connected a person is*
**Ring Leaders / Cell Leaders**
Ones with high degree are likely the ring leaders. Mohammed atta is the  ring master, while Nawaf Alhazmi, Hani Honjouir, Khalid Alimhdar, Ramzi Bin Al-shibh are the local ring leaders.
```{r}
degree(G1)
degree <- degree(G1)
degree
tkplot(G1, layout=layout.kamada.kawai,  vertex.size = degree(G1) )

# Find a way to show degree in the decreasing order and by  filter and show it to others in shiny if possible
```
**Gatekeepers : Betweeness centrality** : *how does the transfer of information or item flow through the network:: Index of potential of a perosn to play brokerage, liaison, gatekeeping*
The transfer of information flows through Mohammad atta followed by  Nawaf Alhazmi and Hani hanjour, Khalid Almihdar.  They are the key information radiators. 
In a closed  network, the objective is to maximise the information flow with minimised actors involved. Simply because the more actors are involved the  increased is the chance of exposure which is what closed networks try to avoid. Hence information has to flow through the shortest path and hence through them.
Usually Betweeneness centrality would indicate that the persons is an important gatekeeper of information betweeen disparate groups.
```{r}
bet1=betweenness(G1)
sort(bet1, decreasing =  TRUE)


```
Here, if Mohammed Atta is not the strategic core, then  he is highly likely to act as the gatekeeper or in other words shielding the core strategic members of the network.
*Who should we pursue to find more core ties* : Mohammed atta  as given out by the  betweenness
REf:  http://keylines.com/social-network-analytics

**Closeness Centrality** : *How long does it take to spread information from s to all other nodes sequentially.*
i.e If you want to spread the information quick, then who  will be used. And  also you can drop dead information to test or elaborate more links.

More central a node, the lesser its distance  to all other nodes
```{r}
# simplify(G1)
# tkplot(G1, layout = layout.fruchterman.reingold)   
V(G1)
c<-closeness(G1, V(G1), mode = "all",NULL, FALSE) 
sort(c, decreasing = TRUE)
```
REf : http://en.wikipedia.org/wiki/Centrality#Closeness_centrality
*Findings:*
It takes the least amount of time for the information to spread from Mohammed Attat to others. Followed by Nawaf Alhazmi, Hani Hanjour, Abdul Aziz Alomari, Marwan Al-shehhi i.e if you have to spread the information fast  through the netowrk e.g instance  of raid  or other vital information then the network will likely choose those points

The fact that Mohammed Atta has High EV and high BC indicates that by tracing him, we can reach more core group of memebers. e.g more people contact generals i.e his / her juniors (low EV). and a general contacts other generals(high EV, high BC)

**High BC - low EV : Operational heads of the ring**
 A vertex or individual with higher levels of betweenness and lower EV centrality may be a 'critical gatekeeper  or an individual that is central to the functioning of the network i.e operational level  activities. 

**Eigen Vector Centrality : Most Well connected (connected to influential person)**
Mohammed Atta is the most well connected person in the network, followed by MArwan Al-shehhi, Ramzi Bin Al-shibh, Abdul Aziz Alomari, Ziad Jarrah, Said Bahaji.

**Most connected**
Mohammed atta is not just only best connected , but he is also connected to most influential person. Next most connected is "Nawaf Alhazmi" then hani hanjour.

```{r}
dd <- degree.distribution(G1)
barplot(dd)


G5 <- G1 - vertex(1)
G5
cluster.distribution(G1,TRUE)

#sizes(G1)
#membership(G1)

```
Community Detection
---------------------------------------
Here all we fed in was who contacted whom adn not even the  no of times a contact was done, and it gave the clustering or community 5. Comparing it with the actual dataset of the hijackers there were 4 hijacks and 4 crashes and lets say 4  communities hence. We then compare the hijackers set with the community formed by our algorithms and we find that  our community cluster formed is quite accurately predicted the hijackers community. 
Our analysis points out that Nawaf Alhazmi, Hani Hanjour, Salem Alhazmi, Khalid Almihdar and Majed Moqed are the prominent members in their community in terms of their eigen vector centrality. Community represented in red color. And in fact they were the ones who crashed Fligh AA #77 that crashed into pentagon.
Similarly Ahmed Alhaznaw, Saeed Alghamdi, Ahmed Alnaw and friend represented in green , in reality were responsible for UA #93 that crashed into Pennsylvania, are clustered in a community.
Similarly if we have a  network of terrorist, we can tell even without having other attribute information, the different clusters of network and who are the critical players in the community and who are the link chain from one community to another community.

```{r}
wc <- walktrap.community(G1)
modularity(wc)
membership(wc)
plot( wc, G1, layout = layout.fruchterman.reingold )
plot( wc, G1, layout = layout.kamada.kawai, vertex.size = degree(G1) )
cor(degree(G1),20*evcent(G1)$vector)

# plot(G1, vertex.color = membership(wc))

fg <- fastgreedy.community(G1)
modularity(fg)
membership(fg)
plot(fg, G1, layout = layout.fruchterman.reingold)
dendPlot(fg)

ebc <- edge.betweenness.community(G1)
modularity(ebc)
membership(ebc)
plot(ebc, G1, layout = layout.fruchterman.reingold)

sc <- spinglass.community(G1)
le<- leading.eigenvector.community(G1)
# le
# compare(sc,le,method="rand")
# compare(membership(sc),membership(le))

plot(le, G1, layout = layout.fruchterman.reingold)

subcomponent(G1,1,"all")
subcomponent(G1,"Mohamed Atta","all")

TA = subcomponent(G1,"Nawaf Alhazmi","in")
TA
subcomponent(G1,"Khalid Almihdar","all")
subcomponent(G1,"Nawaf Alhazmi","in")
#subcomponent(G1,1,"in")
#subcomponent(G1,13,"in")
DtWithName[1,1]
DtWithName[1,13] 
tkplot(G1)
 # khalid degree 10, nawaf 14
degree(G1)

#gl <- graphlets(G1, niter=1000)
# if not a direct way to find out, then the first 14 vertices of nawaf and first 10 of khalid, if found to intersect then it points out the potential suspect list, since the individual will be common to both at first contact point, then the next common  nodes between them will be interesting to pursue.

GEdge <- get.edgelist(G1, names = TRUE)
GEdge[13,]

comps <- decompose.graph(G1, min.vertices=4)
comps
comps[[1]]
plot(comps[[1]], layout = layout.fruchterman.reingold)
sapply(comps, diameter)

rglplot(G1, layout = layout.fruchterman.reingold(G1, dim=3))



```


**Finding linking chain across communities**
```{r}
# Minimum number of nodes to be removed to eliminate paths from source to target.
# i.e finding out which nodes should be removed
edge.connectivity(G1,1,13)
# link between Nawaf and Ahmed can be broken by removing the node

# Nawaf and mohammed atta are more well connected. To break theie connection we will have to break the node ??? 13 number of nodes.
DtWithName[1,1]
DtWithName[1,7] 
edge.connectivity(G1,1,7)
edge.connectivity(G1,7,1)
edge.connectivity(G1,19,1)

DtWithName[1,5] 
DtWithName[1,22] 
# shortest path between  atta and wail is via
shortest.paths(G1,5,22)

plot( wc, G1, layout = layout.kamada.kawai )

DtWithName[1,13] 
tkplot(G1, layout = layout.fruchterman.reingold)
gl <- graphlets(G1, niter=10)



```

**Finding Brokerage**
```{r}
# install.packages('sna')
library('sna')
wc <- walktrap.community(G1)
b <-brokerage(DtWithName, as.vector(membership(wc)))
b$raw.nli[,1]


```
*Coordinator Role* : One who mediates contact between tow individuals in his or her group.

```{r}
Coord <- b$raw.nli
colnames(DtWithName)
Coord
CoordWithName <- cbind(Coord,colnames(DtWithName))
CoordWithName[1:2,1:3]
as.numeric(CoordWithName[,1])
CoordWithName[order(-as.numeric(CoordWithName[,1])),]


b$raw.nli[1:5,1:2]
# b$raw.nli[1:5,1:2]
b$raw.nli[order(-b$raw.nli[,1]),]

sort(b$raw.nli[1:5,1:2])
[,w_I]

wc <- walktrap.community(G1)
wc
modularity(wc)
as.vector(membership(wc))

plot( wc, G1, layout = layout.fruchterman.reingold )



b-> brokerage(G)
#Draw a random network with 3 groups
MDat3G<-rgraph(15)
GDat3G<-graph.adjacency(MDat3G, mode=c("undirected")) 
tkplot(GDat3G, layout = layout.fruchterman.reingold)
cl<-rep(1:3,5)
cl
#Compute a brokerage object
b<-brokerage(g,cl)
summary(b)

# For now, we have graph of terrorist network, now we need to provide the class membership  of the graph to find the brokerage between groups.
DtWithName[1:5,1:5]

graph.matrix(GDat3G)




```





SIMULATION : What if mohammad atta was neutralised  
-----------------------
How would the network look like. How would their operational efficiencies be affected. 
Would the network be more star like then ?

```{r}
G2 <-  G1 - vertex("Mohamed Atta")
V(G2)$label.cex <- 2.2 * as.vector(degree(G2)) / max(as.vector(degree(G2)))+ .2
V(G2)$label.color <- rgb(0, 0, .2, .8)
#V(G1)$frame.color <- NA
simplify(G2)
tkplot(G2, layout = layout.fruchterman.reingold)   

G3 <- G2 - vertex("Nawaf Alhazmi")
simplify(G3)
tkplot(G3, layout = layout.fruchterman.reingold)   

G4 <- G2 - vertex("Hani Hanjour")
simplify(G4)
tkplot(G4, layout = layout.fruchterman.reingold)   

V(G2)$name %in% c("Nawaf Alhazmi","Hani Hanjour")
idx <- which(V(G2)$name %in% c("Nawaf Alhazmi","Hani Hanjour"))
V(G2)[idx]

G4 <- delete.vertices(G2,V(G2)[idx])
G4
G4 <- delete.vertices(G2, V(G2)[degree(G2)==0])

#DAll
#DAll[1:5,1:5]
#DAll[c(1:2,4:5),c(1:2,4:5)]
#DtWithName[7,]
#DtWithName[,7]
#sum(DtWithName[7,])
#sum(DtWithName[,7])
#dim(DtWithName[c(1:6,8:43),c(1:6,8:43)])

SimDAll <-  DtWithName[c(1:6,8:43),c(1:6,8:43)]

colnames(SimDAll) = c("Nawaf Alhazmi","Ahmed Alnami","Saeed Alghamdi","Ahmed Alghamdi","Hamza Alghamdi","Abdul Aziz Alomari","Ramzi Bin al-Shibh","Salem Alhazmi","Hani Hanjour","Yazid Sufaat","Walid Ba Attas","Khalid Almihdar","Majed Moqed","Nabil al - Marabh","Ahmed Al Haznaw","Raed Hijazi","Mohand Alsheri","Ziad Jarrah","Waleed Alshehri","Marwan Al-shehhi","Wail Alshehri","Satam Suqami","Fayez Ahmed","Said Bahaji","Zakariya Essabar","Mounir El Motassadeq","Mohamed Haydar Zammar","Mahmoun Darkazanli","Essid Sami","Abdelghani Mzoudi","Ahmed Khalil","Imad Eddin","Agus Budi man","Mustafa Ahmed al-Hisawi","Khalid Shaikh Mohammed","Zacarias Moussaoui","Faisal Al Salmi","Rayed Mohammed Abdullah","Fahad al Quso","Ahmed Al-Haha","Bandar Alhazmi","Mohamed Abdi")
SimDAll
G<-graph.adjacency(SimDAll, mode=c("undirected")) 


cent<-data.frame(bet=betweenness(G),eig=evcent(G)$vector) 
cent
# V1 0.591 = 191.59*betcoef +intercept
# 0.591 = 191.59 * 0.00263 + 0.23 = (0.733) residual then is  -0.14
lm(eig~bet,data=cent)
 # eig = 0.00263 * bet + 0.23 implies that there is very low relationship between the  betweenness and the eigen vector when it comes to terrorist network relation. this means that the more connected a terrorist is does not mean he is  connected to other critical nodes. He might in fact be just a gatekeeper i.e he sanitise the core of the network from the operational activities so that if a operational actor is compromised then it does not lead to compromise of the core networks. this increases the resilience of the terrorist networks i.e cell operations prevent one cells compromise from propagating to the whole network compromise. This means whatever comprimise happens at the operational level, the core is never compromised. Gatekeepers are important to break the operational strength of the network, while they do not compromise the true strategic strenght of the network.
#  A strategy must be devised keeping in mind the structure of the network. Identyfing  is not the  key, its a important event  but not the key. The key is maximising the knowledge to the fullest without letting the enemy know that their network has been compromised.Just as breaking the enigma was not the key. The key is then to using the information gained to the maximum full potential, without letting the enemy know that the  network has been compromised. You must be ready to   operational level, the terror network will be able to outlast. 

# Correlating with the maoist network.

lm(eig~bet,data=cent)$residuals
# Extremely large value of residuals indicate that the general assumption do not hold true for that particular instance and we can then look at why is the general assumption not holding true for that and wht is the factor that affects so. This might lead to comple new finding s as to in what case can we expect different result.

res<-as.vector(lm(eig~bet,data=cent)$residuals)   
cent<-transform(cent,res=res)
cent


V(G)$label.cex <- 2.2 * as.vector(degree(G)) / max(as.vector(degree(G)))+ .2
V(G1)$label.color <- rgb(0, 0, .2, .8)
#V(G1)$frame.color <- NA
simplify(G)
tkplot(G, layout = layout.fruchterman.reingold)   

plot(G, layout = layout.fruchterman.reingold, vertex.size = 20*evcent(G)$vector, vertex.label = as.vector(rownames(cent)), main = 'Network Visualization in R')


```





**Critical Gatekeeper** : 
Higher betweenness and lower EV centrality.

Connects people to the network who otherwise would be isolated.
In the network,  nawaf alhazmi, hani hajour are the possible critical gatekeepers.

Lower Betweeness and higher EV, people likely at core of netowkr or those well connected






```{r, echo=FALSE}
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
